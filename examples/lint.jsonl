{"path":"/adapters/pytorch/grep_linter.py","line":227,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (81 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/grep_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"\"\"\"\nGeneric linter that greps for a pattern and optionally suggests replacements.\n\"\"\"\n\nimport argparse\nimport json\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom typing import Any, List, NamedTuple, Optional\n\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\ndef run_command(\n    args: List[str],\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef lint_file(\n    matching_line: str,\n    allowlist_pattern: str,\n    replace_pattern: str,\n    linter_name: str,\n    error_name: str,\n    error_description: str,\n) -> Optional[LintMessage]:\n    # matching_line looks like:\n    #   tools/linter/clangtidy_linter.py:13:import foo.bar.baz\n    split = matching_line.split(\":\")\n    filename = split[0]\n\n    if allowlist_pattern:\n        try:\n            proc = run_command([\"grep\", \"-nEHI\", allowlist_pattern, filename])\n        except Exception as err:\n            return LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=linter_name,\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                        stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                    )\n                ),\n            )\n\n        # allowlist pattern was found, abort lint\n        if proc.returncode == 0:\n            return None\n\n    original = None\n    replacement = None\n    if replace_pattern:\n        with open(filename, \"r\") as f:\n            original = f.read()\n\n        try:\n            proc = run_command([\"sed\", \"-r\", replace_pattern, filename])\n            replacement = proc.stdout.decode(\"utf-8\")\n        except Exception as err:\n            return LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=linter_name,\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                        stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                    )\n                ),\n            )\n\n    return LintMessage(\n        path=split[0],\n        line=int(split[1]) if len(split) > 1 else None,\n        char=None,\n        code=linter_name,\n        severity=LintSeverity.ERROR,\n        name=error_name,\n        original=original,\n        replacement=replacement,\n        description=error_description,\n    )\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"grep wrapper linter.\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--pattern\",\n        required=True,\n        help=\"pattern to grep for\",\n    )\n    parser.add_argument(\n        \"--allowlist-pattern\",\n        help=\"if this pattern is true in the file, we don't grep for pattern\",\n    )\n    parser.add_argument(\n        \"--linter-name\",\n        required=True,\n        help=\"name of the linter\",\n    )\n    parser.add_argument(\n        \"--match-first-only\",\n        action=\"store_true\",\n        help=\"only match the first hit in the file\",\n    )\n    parser.add_argument(\n        \"--error-name\",\n        required=True,\n        help=\"human-readable description of what the error is\",\n    )\n    parser.add_argument(\n        \"--error-description\",\n        required=True,\n        help=\"message to display when the pattern is found\",\n    )\n    parser.add_argument(\n        \"--replace-pattern\",\n        help=(\n            \"the form of a pattern passed to `sed -r`. \"\n            \"If specified, this will become proposed replacement text.\"\n        ),\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    files_with_matches = []\n    if args.match_first_only:\n        files_with_matches = [\"--files-with-matches\"]\n\n    try:\n        proc = run_command(\n            [\"grep\", \"-nEHI\", *files_with_matches, args.pattern, *args.filenames]\n        )\n    except Exception as err:\n        err_msg = LintMessage(\n            path=None,\n            line=None,\n            char=None,\n            code=args.linter_name,\n            severity=LintSeverity.ERROR,\n            name=\"command-failed\",\n            original=None,\n            replacement=None,\n            description=(\n                f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                if not isinstance(err, subprocess.CalledProcessError)\n                else (\n                    \"COMMAND (exit code {returncode})\\n\"\n                    \"{command}\\n\\n\"\n                    \"STDERR\\n{stderr}\\n\\n\"\n                    \"STDOUT\\n{stdout}\"\n                ).format(\n                    returncode=err.returncode,\n                    command=\" \".join(as_posix(x) for x in err.cmd),\n                    stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                    stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                )\n            ),\n        )\n        print(json.dumps(err_msg._asdict()), flush=True)\n        exit(0)\n\n    lines = proc.stdout.decode().splitlines()\n    for line in lines:\n        lint_message = lint_file(\n            line,\n            args.allowlist_pattern,\n            args.replace_pattern,\n            args.linter_name,\n            args.error_name,\n            args.error_description,\n        )\n        if lint_message is not None:\n            print(json.dumps(lint_message._asdict()), flush=True)\n\n\nif __name__ == \"__main__\":\n    main()\n","replacement":"\"\"\"\nGeneric linter that greps for a pattern and optionally suggests replacements.\n\"\"\"\n\nimport argparse\nimport json\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom typing import Any, List, NamedTuple, Optional\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\ndef run_command(\n    args: List[str],\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef lint_file(\n    matching_line: str,\n    allowlist_pattern: str,\n    replace_pattern: str,\n    linter_name: str,\n    error_name: str,\n    error_description: str,\n) -> Optional[LintMessage]:\n    # matching_line looks like:\n    #   tools/linter/clangtidy_linter.py:13:import foo.bar.baz\n    split = matching_line.split(\":\")\n    filename = split[0]\n\n    if allowlist_pattern:\n        try:\n            proc = run_command([\"grep\", \"-nEHI\", allowlist_pattern, filename])\n        except Exception as err:\n            return LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=linter_name,\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                        stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                    )\n                ),\n            )\n\n        # allowlist pattern was found, abort lint\n        if proc.returncode == 0:\n            return None\n\n    original = None\n    replacement = None\n    if replace_pattern:\n        with open(filename, \"r\") as f:\n            original = f.read()\n\n        try:\n            proc = run_command([\"sed\", \"-r\", replace_pattern, filename])\n            replacement = proc.stdout.decode(\"utf-8\")\n        except Exception as err:\n            return LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=linter_name,\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                        stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                    )\n                ),\n            )\n\n    return LintMessage(\n        path=split[0],\n        line=int(split[1]) if len(split) > 1 else None,\n        char=None,\n        code=linter_name,\n        severity=LintSeverity.ERROR,\n        name=error_name,\n        original=original,\n        replacement=replacement,\n        description=error_description,\n    )\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"grep wrapper linter.\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--pattern\",\n        required=True,\n        help=\"pattern to grep for\",\n    )\n    parser.add_argument(\n        \"--allowlist-pattern\",\n        help=\"if this pattern is true in the file, we don't grep for pattern\",\n    )\n    parser.add_argument(\n        \"--linter-name\",\n        required=True,\n        help=\"name of the linter\",\n    )\n    parser.add_argument(\n        \"--match-first-only\",\n        action=\"store_true\",\n        help=\"only match the first hit in the file\",\n    )\n    parser.add_argument(\n        \"--error-name\",\n        required=True,\n        help=\"human-readable description of what the error is\",\n    )\n    parser.add_argument(\n        \"--error-description\",\n        required=True,\n        help=\"message to display when the pattern is found\",\n    )\n    parser.add_argument(\n        \"--replace-pattern\",\n        help=(\n            \"the form of a pattern passed to `sed -r`. \"\n            \"If specified, this will become proposed replacement text.\"\n        ),\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    files_with_matches = []\n    if args.match_first_only:\n        files_with_matches = [\"--files-with-matches\"]\n\n    try:\n        proc = run_command(\n            [\"grep\", \"-nEHI\", *files_with_matches, args.pattern, *args.filenames]\n        )\n    except Exception as err:\n        err_msg = LintMessage(\n            path=None,\n            line=None,\n            char=None,\n            code=args.linter_name,\n            severity=LintSeverity.ERROR,\n            name=\"command-failed\",\n            original=None,\n            replacement=None,\n            description=(\n                f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                if not isinstance(err, subprocess.CalledProcessError)\n                else (\n                    \"COMMAND (exit code {returncode})\\n\"\n                    \"{command}\\n\\n\"\n                    \"STDERR\\n{stderr}\\n\\n\"\n                    \"STDOUT\\n{stdout}\"\n                ).format(\n                    returncode=err.returncode,\n                    command=\" \".join(as_posix(x) for x in err.cmd),\n                    stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                    stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                )\n            ),\n        )\n        print(json.dumps(err_msg._asdict()), flush=True)\n        exit(0)\n\n    lines = proc.stdout.decode().splitlines()\n    for line in lines:\n        lint_message = lint_file(\n            line,\n            args.allowlist_pattern,\n            args.replace_pattern,\n            args.linter_name,\n            args.error_name,\n            args.error_description,\n        )\n        if lint_message is not None:\n            print(json.dumps(lint_message._asdict()), flush=True)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"path":"/adapters/pytorch/flake8_linter.py","line":82,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (83 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/flake8_linter.py","line":89,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (83 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/flake8_linter.py","line":123,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (87 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/flake8_linter.py","line":144,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (86 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/flake8_linter.py","line":173,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (80 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/flake8_linter.py","line":299,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (82 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/flake8_linter.py","line":302,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (88 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/flake8_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"import argparse\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom typing import Any, Dict, List, NamedTuple, Optional, Pattern, Set\n\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\n# fmt: off\n# https://www.flake8rules.com/\nDOCUMENTED_IN_FLAKE8RULES: Set[str] = {\n    \"E101\", \"E111\", \"E112\", \"E113\", \"E114\", \"E115\", \"E116\", \"E117\",\n    \"E121\", \"E122\", \"E123\", \"E124\", \"E125\", \"E126\", \"E127\", \"E128\", \"E129\",\n    \"E131\", \"E133\",\n    \"E201\", \"E202\", \"E203\",\n    \"E211\",\n    \"E221\", \"E222\", \"E223\", \"E224\", \"E225\", \"E226\", \"E227\", \"E228\",\n    \"E231\",\n    \"E241\", \"E242\",\n    \"E251\",\n    \"E261\", \"E262\", \"E265\", \"E266\",\n    \"E271\", \"E272\", \"E273\", \"E274\", \"E275\",\n    \"E301\", \"E302\", \"E303\", \"E304\", \"E305\", \"E306\",\n    \"E401\", \"E402\",\n    \"E501\", \"E502\",\n    \"E701\", \"E702\", \"E703\", \"E704\",\n    \"E711\", \"E712\", \"E713\", \"E714\",\n    \"E721\", \"E722\",\n    \"E731\",\n    \"E741\", \"E742\", \"E743\",\n    \"E901\", \"E902\", \"E999\",\n    \"W191\",\n    \"W291\", \"W292\", \"W293\",\n    \"W391\",\n    \"W503\", \"W504\",\n    \"W601\", \"W602\", \"W603\", \"W604\", \"W605\",\n    \"F401\", \"F402\", \"F403\", \"F404\", \"F405\",\n    \"F811\", \"F812\",\n    \"F821\", \"F822\", \"F823\",\n    \"F831\",\n    \"F841\",\n    \"F901\",\n    \"C901\",\n}\n\n# https://pypi.org/project/flake8-comprehensions/#rules\nDOCUMENTED_IN_FLAKE8COMPREHENSIONS: Set[str] = {\n    \"C400\", \"C401\", \"C402\", \"C403\", \"C404\", \"C405\", \"C406\", \"C407\", \"C408\", \"C409\",\n    \"C410\",\n    \"C411\", \"C412\", \"C413\", \"C413\", \"C414\", \"C415\", \"C416\",\n}\n\n# https://github.com/PyCQA/flake8-bugbear#list-of-warnings\nDOCUMENTED_IN_BUGBEAR: Set[str] = {\n    \"B001\", \"B002\", \"B003\", \"B004\", \"B005\", \"B006\", \"B007\", \"B008\", \"B009\", \"B010\",\n    \"B011\", \"B012\", \"B013\", \"B014\", \"B015\",\n    \"B301\", \"B302\", \"B303\", \"B304\", \"B305\", \"B306\",\n    \"B901\", \"B902\", \"B903\", \"B950\",\n}\n# fmt: on\n\n\n# stdin:2: W802 undefined name 'foo'\n# stdin:3:6: T484 Name 'foo' is not defined\n# stdin:3:-100: W605 invalid escape sequence '\\/'\n# stdin:3:1: E302 expected 2 blank lines, found 1\nRESULTS_RE: Pattern[str] = re.compile(\n    r\"\"\"(?mx)\n    ^\n    (?P<file>.*?):\n    (?P<line>\\d+):\n    (?:(?P<column>-?\\d+):)?\n    \\s(?P<code>\\S+?):?\n    \\s(?P<message>.*)\n    $\n    \"\"\"\n)\n\n\ndef _test_results_re() -> None:\n    \"\"\"\n    >>> def t(s): return RESULTS_RE.search(s).groupdict()\n\n    >>> t(r\"file.py:80:1: E302 expected 2 blank lines, found 1\")\n    ... # doctest: +NORMALIZE_WHITESPACE\n    {'file': 'file.py', 'line': '80', 'column': '1', 'code': 'E302',\n     'message': 'expected 2 blank lines, found 1'}\n\n    >>> t(r\"file.py:7:1: P201: Resource `stdout` is acquired but not always released.\")\n    ... # doctest: +NORMALIZE_WHITESPACE\n    {'file': 'file.py', 'line': '7', 'column': '1', 'code': 'P201',\n     'message': 'Resource `stdout` is acquired but not always released.'}\n\n    >>> t(r\"file.py:8:-10: W605 invalid escape sequence '/'\")\n    ... # doctest: +NORMALIZE_WHITESPACE\n    {'file': 'file.py', 'line': '8', 'column': '-10', 'code': 'W605',\n     'message': \"invalid escape sequence '/'\"}\n    \"\"\"\n    pass\n\n\ndef _run_command(\n    args: List[str],\n    *,\n    extra_env: Optional[Dict[str, str]],\n) -> \"subprocess.CompletedProcess[str]\":\n    logging.debug(\n        \"$ %s\",\n        \" \".join(\n            ([f\"{k}={v}\" for (k, v) in extra_env.items()] if extra_env else []) + args\n        ),\n    )\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            check=True,\n            encoding=\"utf-8\",\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef run_command(\n    args: List[str],\n    *,\n    extra_env: Optional[Dict[str, str]],\n    retries: int,\n) -> \"subprocess.CompletedProcess[str]\":\n    remaining_retries = retries\n    while True:\n        try:\n            return _run_command(args, extra_env=extra_env)\n        except subprocess.CalledProcessError as err:\n            if remaining_retries == 0 or not re.match(\n                r\"^ERROR:1:1: X000 linting with .+ timed out after \\d+ seconds\",\n                err.stdout,\n            ):\n                raise err\n            remaining_retries -= 1\n            logging.warning(\n                \"(%s/%s) Retrying because command failed with: %r\",\n                retries - remaining_retries,\n                retries,\n                err,\n            )\n            time.sleep(1)\n\n\ndef get_issue_severity(code: str) -> LintSeverity:\n    # \"B901\": `return x` inside a generator\n    # \"B902\": Invalid first argument to a method\n    # \"B903\": __slots__ efficiency\n    # \"B950\": Line too long\n    # \"C4\": Flake8 Comprehensions\n    # \"C9\": Cyclomatic complexity\n    # \"E2\": PEP8 horizontal whitespace \"errors\"\n    # \"E3\": PEP8 blank line \"errors\"\n    # \"E5\": PEP8 line length \"errors\"\n    # \"F401\": Name imported but unused\n    # \"F403\": Star imports used\n    # \"F405\": Name possibly from star imports\n    # \"T400\": type checking Notes\n    # \"T49\": internal type checker errors or unmatched messages\n    if any(\n        code.startswith(x)\n        for x in [\n            \"B9\",\n            \"C4\",\n            \"C9\",\n            \"E2\",\n            \"E3\",\n            \"E5\",\n            \"F401\",\n            \"F403\",\n            \"F405\",\n            \"T400\",\n            \"T49\",\n        ]\n    ):\n        return LintSeverity.ADVICE\n\n    # \"F821\": Undefined name\n    # \"E999\": syntax error\n    if any(code.startswith(x) for x in [\"F821\", \"E999\"]):\n        return LintSeverity.ERROR\n\n    # \"F\": PyFlakes Error\n    # \"B\": flake8-bugbear Error\n    # \"E\": PEP8 \"Error\"\n    # \"W\": PEP8 Warning\n    # possibly other plugins...\n    return LintSeverity.WARNING\n\n\ndef get_issue_documentation_url(code: str) -> str:\n    if code in DOCUMENTED_IN_FLAKE8RULES:\n        return f\"https://www.flake8rules.com/rules/{code}.html\"\n\n    if code in DOCUMENTED_IN_FLAKE8COMPREHENSIONS:\n        return \"https://pypi.org/project/flake8-comprehensions/#rules\"\n\n    if code in DOCUMENTED_IN_BUGBEAR:\n        return \"https://github.com/PyCQA/flake8-bugbear#list-of-warnings\"\n\n    return \"\"\n\n\ndef check_files(\n    filenames: List[str],\n    flake8_plugins_path: Optional[str],\n    severities: Dict[str, LintSeverity],\n    retries: int,\n) -> List[LintMessage]:\n    try:\n        proc = run_command(\n            [sys.executable, \"-mflake8\", \"--exit-zero\"] + filenames,\n            extra_env={\"FLAKE8_PLUGINS_PATH\": flake8_plugins_path}\n            if flake8_plugins_path\n            else None,\n            retries=retries,\n        )\n    except (OSError, subprocess.CalledProcessError) as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=\"FLAKE8\",\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.strip() or \"(empty)\",\n                        stdout=err.stdout.strip() or \"(empty)\",\n                    )\n                ),\n            )\n        ]\n\n    return [\n        LintMessage(\n            path=match[\"file\"],\n            name=match[\"code\"],\n            description=\"{}\\nSee {}\".format(\n                match[\"message\"],\n                get_issue_documentation_url(match[\"code\"]),\n            ),\n            line=int(match[\"line\"]),\n            char=int(match[\"column\"])\n            if match[\"column\"] is not None and not match[\"column\"].startswith(\"-\")\n            else None,\n            code=\"FLAKE8\",\n            severity=severities.get(match[\"code\"]) or get_issue_severity(match[\"code\"]),\n            original=None,\n            replacement=None,\n        )\n        for match in RESULTS_RE.finditer(proc.stdout)\n    ]\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Flake8 wrapper linter.\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--flake8-plugins-path\",\n        help=\"FLAKE8_PLUGINS_PATH env value\",\n    )\n    parser.add_argument(\n        \"--severity\",\n        action=\"append\",\n        help=\"map code to severity (e.g. `B950:advice`)\",\n    )\n    parser.add_argument(\n        \"--retries\",\n        default=3,\n        type=int,\n        help=\"times to retry timed out flake8\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    flake8_plugins_path = (\n        None\n        if args.flake8_plugins_path is None\n        else os.path.realpath(args.flake8_plugins_path)\n    )\n\n    severities: Dict[str, LintSeverity] = {}\n    if args.severity:\n        for severity in args.severity:\n            parts = severity.split(\":\", 1)\n            assert len(parts) == 2, f\"invalid severity `{severity}`\"\n            severities[parts[0]] = LintSeverity(parts[1])\n\n    lint_messages = check_files(\n        args.filenames, flake8_plugins_path, severities, args.retries\n    )\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n\n\nif __name__ == \"__main__\":\n    main()\n","replacement":"import argparse\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom typing import Any, Dict, List, NamedTuple, Optional, Pattern, Set\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\n# fmt: off\n# https://www.flake8rules.com/\nDOCUMENTED_IN_FLAKE8RULES: Set[str] = {\n    \"E101\", \"E111\", \"E112\", \"E113\", \"E114\", \"E115\", \"E116\", \"E117\",\n    \"E121\", \"E122\", \"E123\", \"E124\", \"E125\", \"E126\", \"E127\", \"E128\", \"E129\",\n    \"E131\", \"E133\",\n    \"E201\", \"E202\", \"E203\",\n    \"E211\",\n    \"E221\", \"E222\", \"E223\", \"E224\", \"E225\", \"E226\", \"E227\", \"E228\",\n    \"E231\",\n    \"E241\", \"E242\",\n    \"E251\",\n    \"E261\", \"E262\", \"E265\", \"E266\",\n    \"E271\", \"E272\", \"E273\", \"E274\", \"E275\",\n    \"E301\", \"E302\", \"E303\", \"E304\", \"E305\", \"E306\",\n    \"E401\", \"E402\",\n    \"E501\", \"E502\",\n    \"E701\", \"E702\", \"E703\", \"E704\",\n    \"E711\", \"E712\", \"E713\", \"E714\",\n    \"E721\", \"E722\",\n    \"E731\",\n    \"E741\", \"E742\", \"E743\",\n    \"E901\", \"E902\", \"E999\",\n    \"W191\",\n    \"W291\", \"W292\", \"W293\",\n    \"W391\",\n    \"W503\", \"W504\",\n    \"W601\", \"W602\", \"W603\", \"W604\", \"W605\",\n    \"F401\", \"F402\", \"F403\", \"F404\", \"F405\",\n    \"F811\", \"F812\",\n    \"F821\", \"F822\", \"F823\",\n    \"F831\",\n    \"F841\",\n    \"F901\",\n    \"C901\",\n}\n\n# https://pypi.org/project/flake8-comprehensions/#rules\nDOCUMENTED_IN_FLAKE8COMPREHENSIONS: Set[str] = {\n    \"C400\", \"C401\", \"C402\", \"C403\", \"C404\", \"C405\", \"C406\", \"C407\", \"C408\", \"C409\",\n    \"C410\",\n    \"C411\", \"C412\", \"C413\", \"C413\", \"C414\", \"C415\", \"C416\",\n}\n\n# https://github.com/PyCQA/flake8-bugbear#list-of-warnings\nDOCUMENTED_IN_BUGBEAR: Set[str] = {\n    \"B001\", \"B002\", \"B003\", \"B004\", \"B005\", \"B006\", \"B007\", \"B008\", \"B009\", \"B010\",\n    \"B011\", \"B012\", \"B013\", \"B014\", \"B015\",\n    \"B301\", \"B302\", \"B303\", \"B304\", \"B305\", \"B306\",\n    \"B901\", \"B902\", \"B903\", \"B950\",\n}\n# fmt: on\n\n\n# stdin:2: W802 undefined name 'foo'\n# stdin:3:6: T484 Name 'foo' is not defined\n# stdin:3:-100: W605 invalid escape sequence '\\/'\n# stdin:3:1: E302 expected 2 blank lines, found 1\nRESULTS_RE: Pattern[str] = re.compile(\n    r\"\"\"(?mx)\n    ^\n    (?P<file>.*?):\n    (?P<line>\\d+):\n    (?:(?P<column>-?\\d+):)?\n    \\s(?P<code>\\S+?):?\n    \\s(?P<message>.*)\n    $\n    \"\"\"\n)\n\n\ndef _test_results_re() -> None:\n    \"\"\"\n    >>> def t(s): return RESULTS_RE.search(s).groupdict()\n\n    >>> t(r\"file.py:80:1: E302 expected 2 blank lines, found 1\")\n    ... # doctest: +NORMALIZE_WHITESPACE\n    {'file': 'file.py', 'line': '80', 'column': '1', 'code': 'E302',\n     'message': 'expected 2 blank lines, found 1'}\n\n    >>> t(r\"file.py:7:1: P201: Resource `stdout` is acquired but not always released.\")\n    ... # doctest: +NORMALIZE_WHITESPACE\n    {'file': 'file.py', 'line': '7', 'column': '1', 'code': 'P201',\n     'message': 'Resource `stdout` is acquired but not always released.'}\n\n    >>> t(r\"file.py:8:-10: W605 invalid escape sequence '/'\")\n    ... # doctest: +NORMALIZE_WHITESPACE\n    {'file': 'file.py', 'line': '8', 'column': '-10', 'code': 'W605',\n     'message': \"invalid escape sequence '/'\"}\n    \"\"\"\n    pass\n\n\ndef _run_command(\n    args: List[str],\n    *,\n    extra_env: Optional[Dict[str, str]],\n) -> \"subprocess.CompletedProcess[str]\":\n    logging.debug(\n        \"$ %s\",\n        \" \".join(\n            ([f\"{k}={v}\" for (k, v) in extra_env.items()] if extra_env else []) + args\n        ),\n    )\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            check=True,\n            encoding=\"utf-8\",\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef run_command(\n    args: List[str],\n    *,\n    extra_env: Optional[Dict[str, str]],\n    retries: int,\n) -> \"subprocess.CompletedProcess[str]\":\n    remaining_retries = retries\n    while True:\n        try:\n            return _run_command(args, extra_env=extra_env)\n        except subprocess.CalledProcessError as err:\n            if remaining_retries == 0 or not re.match(\n                r\"^ERROR:1:1: X000 linting with .+ timed out after \\d+ seconds\",\n                err.stdout,\n            ):\n                raise err\n            remaining_retries -= 1\n            logging.warning(\n                \"(%s/%s) Retrying because command failed with: %r\",\n                retries - remaining_retries,\n                retries,\n                err,\n            )\n            time.sleep(1)\n\n\ndef get_issue_severity(code: str) -> LintSeverity:\n    # \"B901\": `return x` inside a generator\n    # \"B902\": Invalid first argument to a method\n    # \"B903\": __slots__ efficiency\n    # \"B950\": Line too long\n    # \"C4\": Flake8 Comprehensions\n    # \"C9\": Cyclomatic complexity\n    # \"E2\": PEP8 horizontal whitespace \"errors\"\n    # \"E3\": PEP8 blank line \"errors\"\n    # \"E5\": PEP8 line length \"errors\"\n    # \"F401\": Name imported but unused\n    # \"F403\": Star imports used\n    # \"F405\": Name possibly from star imports\n    # \"T400\": type checking Notes\n    # \"T49\": internal type checker errors or unmatched messages\n    if any(\n        code.startswith(x)\n        for x in [\n            \"B9\",\n            \"C4\",\n            \"C9\",\n            \"E2\",\n            \"E3\",\n            \"E5\",\n            \"F401\",\n            \"F403\",\n            \"F405\",\n            \"T400\",\n            \"T49\",\n        ]\n    ):\n        return LintSeverity.ADVICE\n\n    # \"F821\": Undefined name\n    # \"E999\": syntax error\n    if any(code.startswith(x) for x in [\"F821\", \"E999\"]):\n        return LintSeverity.ERROR\n\n    # \"F\": PyFlakes Error\n    # \"B\": flake8-bugbear Error\n    # \"E\": PEP8 \"Error\"\n    # \"W\": PEP8 Warning\n    # possibly other plugins...\n    return LintSeverity.WARNING\n\n\ndef get_issue_documentation_url(code: str) -> str:\n    if code in DOCUMENTED_IN_FLAKE8RULES:\n        return f\"https://www.flake8rules.com/rules/{code}.html\"\n\n    if code in DOCUMENTED_IN_FLAKE8COMPREHENSIONS:\n        return \"https://pypi.org/project/flake8-comprehensions/#rules\"\n\n    if code in DOCUMENTED_IN_BUGBEAR:\n        return \"https://github.com/PyCQA/flake8-bugbear#list-of-warnings\"\n\n    return \"\"\n\n\ndef check_files(\n    filenames: List[str],\n    flake8_plugins_path: Optional[str],\n    severities: Dict[str, LintSeverity],\n    retries: int,\n) -> List[LintMessage]:\n    try:\n        proc = run_command(\n            [sys.executable, \"-mflake8\", \"--exit-zero\"] + filenames,\n            extra_env={\"FLAKE8_PLUGINS_PATH\": flake8_plugins_path}\n            if flake8_plugins_path\n            else None,\n            retries=retries,\n        )\n    except (OSError, subprocess.CalledProcessError) as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=\"FLAKE8\",\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.strip() or \"(empty)\",\n                        stdout=err.stdout.strip() or \"(empty)\",\n                    )\n                ),\n            )\n        ]\n\n    return [\n        LintMessage(\n            path=match[\"file\"],\n            name=match[\"code\"],\n            description=\"{}\\nSee {}\".format(\n                match[\"message\"],\n                get_issue_documentation_url(match[\"code\"]),\n            ),\n            line=int(match[\"line\"]),\n            char=int(match[\"column\"])\n            if match[\"column\"] is not None and not match[\"column\"].startswith(\"-\")\n            else None,\n            code=\"FLAKE8\",\n            severity=severities.get(match[\"code\"]) or get_issue_severity(match[\"code\"]),\n            original=None,\n            replacement=None,\n        )\n        for match in RESULTS_RE.finditer(proc.stdout)\n    ]\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Flake8 wrapper linter.\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--flake8-plugins-path\",\n        help=\"FLAKE8_PLUGINS_PATH env value\",\n    )\n    parser.add_argument(\n        \"--severity\",\n        action=\"append\",\n        help=\"map code to severity (e.g. `B950:advice`)\",\n    )\n    parser.add_argument(\n        \"--retries\",\n        default=3,\n        type=int,\n        help=\"times to retry timed out flake8\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    flake8_plugins_path = (\n        None\n        if args.flake8_plugins_path is None\n        else os.path.realpath(args.flake8_plugins_path)\n    )\n\n    severities: Dict[str, LintSeverity] = {}\n    if args.severity:\n        for severity in args.severity:\n            parts = severity.split(\":\", 1)\n            assert len(parts) == 2, f\"invalid severity `{severity}`\"\n            severities[parts[0]] = LintSeverity(parts[1])\n\n    lint_messages = check_files(\n        args.filenames, flake8_plugins_path, severities, args.retries\n    )\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"path":"/adapters/pytorch/pip_init.py","line":37,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (83 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/pip_init.py","line":73,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (86 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/pip_init.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"\"\"\"\nInitializer script that installs stuff to pip.\n\"\"\"\nimport argparse\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\n\nfrom typing import List\n\n\ndef run_command(args: List[str]) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(args, check=True)\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"pip initializer\")\n    parser.add_argument(\n        \"packages\",\n        nargs=\"+\",\n        help=\"pip packages to install\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"--dry-run\", help=\"do not install anything, just print what would be done.\"\n    )\n    parser.add_argument(\n        \"--no-black-binary\",\n        help=\"do not use pre-compiled binaries from pip for black.\",\n        action=\"store_true\",\n    )\n\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET if args.verbose else logging.DEBUG,\n        stream=sys.stderr,\n    )\n\n    pip_args = [\"pip3\", \"install\"]\n\n    # If we are in a global install, use `--user` to install so that you do not\n    # need root access in order to initialize linters.\n    #\n    # However, `pip install --user` interacts poorly with virtualenvs (see:\n    # https://bit.ly/3vD4kvl) and conda (see: https://bit.ly/3KG7ZfU). So in\n    # these cases perform a regular installation.\n    in_conda = os.environ.get(\"CONDA_PREFIX\") is not None\n    in_virtualenv = os.environ.get(\"VIRTUAL_ENV\") is not None\n    if not in_conda and not in_virtualenv:\n        pip_args.append(\"--user\")\n\n    pip_args.extend(args.packages)\n\n    for package in args.packages:\n        package_name, _, version = package.partition(\"=\")\n        if version == \"\":\n            raise RuntimeError(\n                \"Package {package_name} did not have a version specified. \"\n                \"Please specify a version to produce a consistent linting experience.\"\n            )\n        if args.no_black_binary and \"black\" in package_name:\n            pip_args.append(f\"--no-binary={package_name}\")\n\n    dry_run = args.dry_run == \"1\"\n    if dry_run:\n        print(f\"Would have run: {pip_args}\")\n        sys.exit(0)\n\n    run_command(pip_args)\n","replacement":"\"\"\"\nInitializer script that installs stuff to pip.\n\"\"\"\nimport argparse\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nfrom typing import List\n\n\ndef run_command(args: List[str]) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(args, check=True)\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"pip initializer\")\n    parser.add_argument(\n        \"packages\",\n        nargs=\"+\",\n        help=\"pip packages to install\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"--dry-run\", help=\"do not install anything, just print what would be done.\"\n    )\n    parser.add_argument(\n        \"--no-black-binary\",\n        help=\"do not use pre-compiled binaries from pip for black.\",\n        action=\"store_true\",\n    )\n\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET if args.verbose else logging.DEBUG,\n        stream=sys.stderr,\n    )\n\n    pip_args = [\"pip3\", \"install\"]\n\n    # If we are in a global install, use `--user` to install so that you do not\n    # need root access in order to initialize linters.\n    #\n    # However, `pip install --user` interacts poorly with virtualenvs (see:\n    # https://bit.ly/3vD4kvl) and conda (see: https://bit.ly/3KG7ZfU). So in\n    # these cases perform a regular installation.\n    in_conda = os.environ.get(\"CONDA_PREFIX\") is not None\n    in_virtualenv = os.environ.get(\"VIRTUAL_ENV\") is not None\n    if not in_conda and not in_virtualenv:\n        pip_args.append(\"--user\")\n\n    pip_args.extend(args.packages)\n\n    for package in args.packages:\n        package_name, _, version = package.partition(\"=\")\n        if version == \"\":\n            raise RuntimeError(\n                \"Package {package_name} did not have a version specified. \"\n                \"Please specify a version to produce a consistent linting experience.\"\n            )\n        if args.no_black_binary and \"black\" in package_name:\n            pip_args.append(f\"--no-binary={package_name}\")\n\n    dry_run = args.dry_run == \"1\"\n    if dry_run:\n        print(f\"Would have run: {pip_args}\")\n        sys.exit(0)\n\n    run_command(pip_args)\n"}
{"path":"/adapters/pytorch/update_s3.py","line":74,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (88 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/black_isort_linter.py","line":5,"char":1,"code":"FLAKE8","severity":"advice","name":"F401","description":"'io' imported but unused\nSee https://www.flake8rules.com/rules/F401.html"}
{"path":"/adapters/pytorch/black_isort_linter.py","line":92,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (80 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/circleci_linter.py","line":2,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (84 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/circleci_linter.py","line":49,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (83 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/circleci_linter.py","line":115,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (108 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/circleci_linter.py","line":135,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (85 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/circleci_linter.py","line":140,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (96 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/circleci_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"\"\"\"\nChecks that the configuration in .circleci/config.yml has been properly regenerated.\n\"\"\"\n\nimport argparse\nimport json\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom typing import List, NamedTuple, Optional\n\n\nCHECKED_IN_FILE = \"config.yml\"\nREGENERATION_SCRIPT = \"regenerate.sh\"\n\nPARENT_DIR = os.path.basename(os.path.dirname(os.path.abspath(__file__)))\nREADME_PATH = os.path.join(PARENT_DIR, \"README.md\")\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\ndef run_command(args: List[str], cwd: str) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            cwd=cwd,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            check=True,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef run_check(\n    regen_script_working_dir: str, regen_script: str, config_file: str\n) -> List[LintMessage]:\n    try:\n        proc = run_command([\"python3\", regen_script], regen_script_working_dir)\n    except Exception as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=\"CIRCLECI\",\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                        stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                    )\n                ),\n            )\n        ]\n\n    with open(config_file, mode=\"rb\") as f:\n        config = f.read()\n    if proc.stdout == config:\n        return []\n\n    return [\n        LintMessage(\n            path=config_file,\n            line=None,\n            char=None,\n            code=\"CIRCLECI\",\n            severity=LintSeverity.ERROR,\n            name=\"config inconsistency\",\n            original=config.decode(\"utf-8\"),\n            replacement=proc.stdout.decode(\"utf-8\"),\n            description=(\n                \"The checked-in CircleCI config.yml file does not match what was generated by the scripts. \"\n                \"Re-run with '-a' to accept changes.\"\n            ),\n        )\n    ]\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"circleci consistency linter\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--config-yml\",\n        required=True,\n        help=\"location of config.yml\",\n    )\n    parser.add_argument(\n        \"--regen-script-working-dir\",\n        required=True,\n        help=\"this script will chdir to this argument before running --regen-script\",\n    )\n    parser.add_argument(\n        \"--regen-script\",\n        required=True,\n        help=\"location of the config generation script, relative to --regen-script-working-dir\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET if args.verbose else logging.DEBUG,\n        stream=sys.stderr,\n    )\n\n    for lint_message in run_check(\n        args.regen_script_working_dir, args.regen_script, args.config_yml\n    ):\n        print(json.dumps(lint_message._asdict()), flush=True)\n","replacement":"\"\"\"\nChecks that the configuration in .circleci/config.yml has been properly regenerated.\n\"\"\"\n\nimport argparse\nimport json\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom typing import List, NamedTuple, Optional\n\nCHECKED_IN_FILE = \"config.yml\"\nREGENERATION_SCRIPT = \"regenerate.sh\"\n\nPARENT_DIR = os.path.basename(os.path.dirname(os.path.abspath(__file__)))\nREADME_PATH = os.path.join(PARENT_DIR, \"README.md\")\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\ndef run_command(args: List[str], cwd: str) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            cwd=cwd,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            check=True,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef run_check(\n    regen_script_working_dir: str, regen_script: str, config_file: str\n) -> List[LintMessage]:\n    try:\n        proc = run_command([\"python3\", regen_script], regen_script_working_dir)\n    except Exception as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=\"CIRCLECI\",\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                        stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                    )\n                ),\n            )\n        ]\n\n    with open(config_file, mode=\"rb\") as f:\n        config = f.read()\n    if proc.stdout == config:\n        return []\n\n    return [\n        LintMessage(\n            path=config_file,\n            line=None,\n            char=None,\n            code=\"CIRCLECI\",\n            severity=LintSeverity.ERROR,\n            name=\"config inconsistency\",\n            original=config.decode(\"utf-8\"),\n            replacement=proc.stdout.decode(\"utf-8\"),\n            description=(\n                \"The checked-in CircleCI config.yml file does not match what was generated by the scripts. \"\n                \"Re-run with '-a' to accept changes.\"\n            ),\n        )\n    ]\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"circleci consistency linter\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--config-yml\",\n        required=True,\n        help=\"location of config.yml\",\n    )\n    parser.add_argument(\n        \"--regen-script-working-dir\",\n        required=True,\n        help=\"this script will chdir to this argument before running --regen-script\",\n    )\n    parser.add_argument(\n        \"--regen-script\",\n        required=True,\n        help=\"location of the config generation script, relative to --regen-script-working-dir\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET if args.verbose else logging.DEBUG,\n        stream=sys.stderr,\n    )\n\n    for lint_message in run_check(\n        args.regen_script_working_dir, args.regen_script, args.config_yml\n    ):\n        print(json.dumps(lint_message._asdict()), flush=True)\n"}
{"path":"/adapters/pytorch/workflow_consistency_linter.py","line":3,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (86 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/workflow_consistency_linter.py","line":65,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (80 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/workflow_consistency_linter.py","line":93,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (80 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/shellcheck_linter.py","line":67,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (80 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/shellcheck_linter.py","line":109,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (96 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/shellcheck_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"import argparse\nimport json\nimport logging\nimport shutil\nimport subprocess\nimport time\nfrom enum import Enum\nfrom typing import List, NamedTuple, Optional\n\n\nLINTER_CODE = \"SHELLCHECK\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef run_command(\n    args: List[str],\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef check_files(\n    files: List[str],\n) -> List[LintMessage]:\n    try:\n        proc = run_command(\n            [\"shellcheck\", \"--external-sources\", \"--format=json1\"] + files\n        )\n    except OSError as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(f\"Failed due to {err.__class__.__name__}:\\n{err}\"),\n            )\n        ]\n    stdout = str(proc.stdout, \"utf-8\").strip()\n    results = json.loads(stdout)[\"comments\"]\n    return [\n        LintMessage(\n            path=result[\"file\"],\n            name=f\"SC{result['code']}\",\n            description=result[\"message\"],\n            line=result[\"line\"],\n            char=result[\"column\"],\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            original=None,\n            replacement=None,\n        )\n        for result in results\n    ]\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"shellcheck runner\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    if shutil.which(\"shellcheck\") is None:\n        err_msg = LintMessage(\n            path=\"<none>\",\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"command-failed\",\n            original=None,\n            replacement=None,\n            description=\"shellcheck is not installed, did you forget to run `lintrunner init`?\",\n        )\n        print(json.dumps(err_msg._asdict()), flush=True)\n        exit(0)\n\n    args = parser.parse_args()\n\n    lint_messages = check_files(args.filenames)\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n","replacement":"import argparse\nimport json\nimport logging\nimport shutil\nimport subprocess\nimport time\nfrom enum import Enum\nfrom typing import List, NamedTuple, Optional\n\nLINTER_CODE = \"SHELLCHECK\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef run_command(\n    args: List[str],\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef check_files(\n    files: List[str],\n) -> List[LintMessage]:\n    try:\n        proc = run_command(\n            [\"shellcheck\", \"--external-sources\", \"--format=json1\"] + files\n        )\n    except OSError as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(f\"Failed due to {err.__class__.__name__}:\\n{err}\"),\n            )\n        ]\n    stdout = str(proc.stdout, \"utf-8\").strip()\n    results = json.loads(stdout)[\"comments\"]\n    return [\n        LintMessage(\n            path=result[\"file\"],\n            name=f\"SC{result['code']}\",\n            description=result[\"message\"],\n            line=result[\"line\"],\n            char=result[\"column\"],\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            original=None,\n            replacement=None,\n        )\n        for result in results\n    ]\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"shellcheck runner\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    if shutil.which(\"shellcheck\") is None:\n        err_msg = LintMessage(\n            path=\"<none>\",\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"command-failed\",\n            original=None,\n            replacement=None,\n            description=\"shellcheck is not installed, did you forget to run `lintrunner init`?\",\n        )\n        print(json.dumps(err_msg._asdict()), flush=True)\n        exit(0)\n\n    args = parser.parse_args()\n\n    lint_messages = check_files(args.filenames)\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n"}
{"path":"/adapters/pytorch/actionlint_linter.py","line":81,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (80 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/actionlint_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"import argparse\nimport concurrent.futures\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport time\nfrom enum import Enum\nfrom typing import List, NamedTuple, Optional, Pattern\n\n\nLINTER_CODE = \"ACTIONLINT\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\nRESULTS_RE: Pattern[str] = re.compile(\n    r\"\"\"(?mx)\n    ^\n    (?P<file>.*?):\n    (?P<line>\\d+):\n    (?P<char>\\d+):\n    \\s(?P<message>.*)\n    \\s(?P<code>\\[.*\\])\n    $\n    \"\"\"\n)\n\n\ndef run_command(\n    args: List[str],\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef check_file(\n    binary: str,\n    file: str,\n) -> List[LintMessage]:\n    try:\n        proc = run_command([binary, file])\n    except OSError as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(f\"Failed due to {err.__class__.__name__}:\\n{err}\"),\n            )\n        ]\n    stdout = str(proc.stdout, \"utf-8\").strip()\n    return [\n        LintMessage(\n            path=match[\"file\"],\n            name=match[\"code\"],\n            description=match[\"message\"],\n            line=int(match[\"line\"]),\n            char=int(match[\"char\"]),\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            original=None,\n            replacement=None,\n        )\n        for match in RESULTS_RE.finditer(stdout)\n    ]\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"actionlint runner\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--binary\",\n        required=True,\n        help=\"actionlint binary path\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    args = parser.parse_args()\n\n    if not os.path.exists(args.binary):\n        err_msg = LintMessage(\n            path=\"<none>\",\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"command-failed\",\n            original=None,\n            replacement=None,\n            description=(\n                f\"Could not find actionlint binary at {args.binary},\"\n                \" you may need to run `lintrunner init`.\"\n            ),\n        )\n        print(json.dumps(err_msg._asdict()), flush=True)\n        exit(0)\n\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=os.cpu_count(),\n        thread_name_prefix=\"Thread\",\n    ) as executor:\n        futures = {\n            executor.submit(\n                check_file,\n                args.binary,\n                filename,\n            ): filename\n            for filename in args.filenames\n        }\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                for lint_message in future.result():\n                    print(json.dumps(lint_message._asdict()), flush=True)\n            except Exception:\n                logging.critical('Failed at \"%s\".', futures[future])\n                raise\n","replacement":"import argparse\nimport concurrent.futures\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport time\nfrom enum import Enum\nfrom typing import List, NamedTuple, Optional, Pattern\n\nLINTER_CODE = \"ACTIONLINT\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\nRESULTS_RE: Pattern[str] = re.compile(\n    r\"\"\"(?mx)\n    ^\n    (?P<file>.*?):\n    (?P<line>\\d+):\n    (?P<char>\\d+):\n    \\s(?P<message>.*)\n    \\s(?P<code>\\[.*\\])\n    $\n    \"\"\"\n)\n\n\ndef run_command(\n    args: List[str],\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef check_file(\n    binary: str,\n    file: str,\n) -> List[LintMessage]:\n    try:\n        proc = run_command([binary, file])\n    except OSError as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(f\"Failed due to {err.__class__.__name__}:\\n{err}\"),\n            )\n        ]\n    stdout = str(proc.stdout, \"utf-8\").strip()\n    return [\n        LintMessage(\n            path=match[\"file\"],\n            name=match[\"code\"],\n            description=match[\"message\"],\n            line=int(match[\"line\"]),\n            char=int(match[\"char\"]),\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            original=None,\n            replacement=None,\n        )\n        for match in RESULTS_RE.finditer(stdout)\n    ]\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"actionlint runner\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--binary\",\n        required=True,\n        help=\"actionlint binary path\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    args = parser.parse_args()\n\n    if not os.path.exists(args.binary):\n        err_msg = LintMessage(\n            path=\"<none>\",\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"command-failed\",\n            original=None,\n            replacement=None,\n            description=(\n                f\"Could not find actionlint binary at {args.binary},\"\n                \" you may need to run `lintrunner init`.\"\n            ),\n        )\n        print(json.dumps(err_msg._asdict()), flush=True)\n        exit(0)\n\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=os.cpu_count(),\n        thread_name_prefix=\"Thread\",\n    ) as executor:\n        futures = {\n            executor.submit(\n                check_file,\n                args.binary,\n                filename,\n            ): filename\n            for filename in args.filenames\n        }\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                for lint_message in future.result():\n                    print(json.dumps(lint_message._asdict()), flush=True)\n            except Exception:\n                logging.critical('Failed at \"%s\".', futures[future])\n                raise\n"}
{"path":"/adapters/pytorch/cmake_linter.py","line":83,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (80 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/cmake_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"import argparse\nimport concurrent.futures\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport time\nfrom enum import Enum\nfrom typing import List, NamedTuple, Optional, Pattern\n\n\nLINTER_CODE = \"CMAKE\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\n# CMakeLists.txt:901: Lines should be <= 80 characters long [linelength]\nRESULTS_RE: Pattern[str] = re.compile(\n    r\"\"\"(?mx)\n    ^\n    (?P<file>.*?):\n    (?P<line>\\d+):\n    \\s(?P<message>.*)\n    \\s(?P<code>\\[.*\\])\n    $\n    \"\"\"\n)\n\n\ndef run_command(\n    args: List[str],\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef check_file(\n    filename: str,\n    config: str,\n) -> List[LintMessage]:\n    try:\n        proc = run_command(\n            [\"cmakelint\", f\"--config={config}\", filename],\n        )\n    except OSError as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(f\"Failed due to {err.__class__.__name__}:\\n{err}\"),\n            )\n        ]\n    stdout = str(proc.stdout, \"utf-8\").strip()\n    return [\n        LintMessage(\n            path=match[\"file\"],\n            name=match[\"code\"],\n            description=match[\"message\"],\n            line=int(match[\"line\"]),\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            original=None,\n            replacement=None,\n        )\n        for match in RESULTS_RE.finditer(stdout)\n    ]\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"cmakelint runner\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--config\",\n        required=True,\n        help=\"location of cmakelint config\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    args = parser.parse_args()\n\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=os.cpu_count(),\n        thread_name_prefix=\"Thread\",\n    ) as executor:\n        futures = {\n            executor.submit(\n                check_file,\n                filename,\n                args.config,\n            ): filename\n            for filename in args.filenames\n        }\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                for lint_message in future.result():\n                    print(json.dumps(lint_message._asdict()), flush=True)\n            except Exception:\n                logging.critical('Failed at \"%s\".', futures[future])\n                raise\n","replacement":"import argparse\nimport concurrent.futures\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport time\nfrom enum import Enum\nfrom typing import List, NamedTuple, Optional, Pattern\n\nLINTER_CODE = \"CMAKE\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\n# CMakeLists.txt:901: Lines should be <= 80 characters long [linelength]\nRESULTS_RE: Pattern[str] = re.compile(\n    r\"\"\"(?mx)\n    ^\n    (?P<file>.*?):\n    (?P<line>\\d+):\n    \\s(?P<message>.*)\n    \\s(?P<code>\\[.*\\])\n    $\n    \"\"\"\n)\n\n\ndef run_command(\n    args: List[str],\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef check_file(\n    filename: str,\n    config: str,\n) -> List[LintMessage]:\n    try:\n        proc = run_command(\n            [\"cmakelint\", f\"--config={config}\", filename],\n        )\n    except OSError as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(f\"Failed due to {err.__class__.__name__}:\\n{err}\"),\n            )\n        ]\n    stdout = str(proc.stdout, \"utf-8\").strip()\n    return [\n        LintMessage(\n            path=match[\"file\"],\n            name=match[\"code\"],\n            description=match[\"message\"],\n            line=int(match[\"line\"]),\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            original=None,\n            replacement=None,\n        )\n        for match in RESULTS_RE.finditer(stdout)\n    ]\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"cmakelint runner\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--config\",\n        required=True,\n        help=\"location of cmakelint config\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    args = parser.parse_args()\n\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=os.cpu_count(),\n        thread_name_prefix=\"Thread\",\n    ) as executor:\n        futures = {\n            executor.submit(\n                check_file,\n                filename,\n                args.config,\n            ): filename\n            for filename in args.filenames\n        }\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                for lint_message in future.result():\n                    print(json.dumps(lint_message._asdict()), flush=True)\n            except Exception:\n                logging.critical('Failed at \"%s\".', futures[future])\n                raise\n"}
{"path":"/adapters/pytorch/clangtidy_linter.py","line":26,"char":1,"code":"FLAKE8","severity":"advice","name":"E302","description":"expected 2 blank lines, found 1\nSee https://www.flake8rules.com/rules/E302.html"}
{"path":"/adapters/pytorch/clangtidy_linter.py","line":57,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (95 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/clangtidy_linter.py","line":163,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (80 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/clangtidy_linter.py","line":182,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (86 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/ufmt_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"import argparse\nimport concurrent.futures\nimport json\nimport logging\nimport os\nimport sys\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any, List, NamedTuple, Optional\n\nfrom ufmt.core import make_black_config, ufmt_string\nfrom usort import Config as UsortConfig\n\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\ndef format_error_message(filename: str, err: Exception) -> LintMessage:\n    return LintMessage(\n        path=filename,\n        line=None,\n        char=None,\n        code=\"UFMT\",\n        severity=LintSeverity.ADVICE,\n        name=\"command-failed\",\n        original=None,\n        replacement=None,\n        description=(f\"Failed due to {err.__class__.__name__}:\\n{err}\"),\n    )\n\n\ndef check_file(\n    filename: str,\n) -> List[LintMessage]:\n    with open(filename, \"rb\") as f:\n        original = f.read().decode(\"utf-8\")\n\n    try:\n        path = Path(filename)\n\n        usort_config = UsortConfig.find(path)\n        black_config = make_black_config(path)\n\n        # Use UFMT API to call both usort and black\n        replacement = ufmt_string(\n            path=path,\n            content=original,\n            usort_config=usort_config,\n            black_config=black_config,\n        )\n\n        if original == replacement:\n            return []\n\n        return [\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=\"UFMT\",\n                severity=LintSeverity.WARNING,\n                name=\"format\",\n                original=original,\n                replacement=replacement,\n                description=\"Run `lintrunner -a` to apply this patch.\",\n            )\n        ]\n    except Exception as err:\n        return [format_error_message(filename, err)]\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Format files with ufmt (black + usort).\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=os.cpu_count(),\n        thread_name_prefix=\"Thread\",\n    ) as executor:\n        futures = {executor.submit(check_file, x): x for x in args.filenames}\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                for lint_message in future.result():\n                    print(json.dumps(lint_message._asdict()), flush=True)\n            except Exception:\n                logging.critical('Failed at \"%s\".', futures[future])\n                raise\n\n\nif __name__ == \"__main__\":\n    main()\n","replacement":"import argparse\nimport concurrent.futures\nimport json\nimport logging\nimport os\nimport sys\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any, List, NamedTuple, Optional\n\nfrom ufmt.core import make_black_config, ufmt_string\nfrom usort import Config as UsortConfig\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\ndef format_error_message(filename: str, err: Exception) -> LintMessage:\n    return LintMessage(\n        path=filename,\n        line=None,\n        char=None,\n        code=\"UFMT\",\n        severity=LintSeverity.ADVICE,\n        name=\"command-failed\",\n        original=None,\n        replacement=None,\n        description=(f\"Failed due to {err.__class__.__name__}:\\n{err}\"),\n    )\n\n\ndef check_file(\n    filename: str,\n) -> List[LintMessage]:\n    with open(filename, \"rb\") as f:\n        original = f.read().decode(\"utf-8\")\n\n    try:\n        path = Path(filename)\n\n        usort_config = UsortConfig.find(path)\n        black_config = make_black_config(path)\n\n        # Use UFMT API to call both usort and black\n        replacement = ufmt_string(\n            path=path,\n            content=original,\n            usort_config=usort_config,\n            black_config=black_config,\n        )\n\n        if original == replacement:\n            return []\n\n        return [\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=\"UFMT\",\n                severity=LintSeverity.WARNING,\n                name=\"format\",\n                original=original,\n                replacement=replacement,\n                description=\"Run `lintrunner -a` to apply this patch.\",\n            )\n        ]\n    except Exception as err:\n        return [format_error_message(filename, err)]\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Format files with ufmt (black + usort).\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=os.cpu_count(),\n        thread_name_prefix=\"Thread\",\n    ) as executor:\n        futures = {executor.submit(check_file, x): x for x in args.filenames}\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                for lint_message in future.result():\n                    print(json.dumps(lint_message._asdict()), flush=True)\n            except Exception:\n                logging.critical('Failed at \"%s\".', futures[future])\n                raise\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"path":"/adapters/pytorch/s3_init.py","line":92,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (98 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/s3_init.py","line":114,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (109 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/s3_init.py","line":115,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (86 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/s3_init.py","line":120,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (81 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/s3_init.py","line":162,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (84 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/black_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"import argparse\nimport concurrent.futures\nimport json\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom typing import Any, BinaryIO, List, NamedTuple, Optional\n\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\ndef _run_command(\n    args: List[str],\n    *,\n    stdin: BinaryIO,\n    timeout: int,\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdin=stdin,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            shell=IS_WINDOWS,  # So batch scripts are found.\n            timeout=timeout,\n            check=True,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef run_command(\n    args: List[str],\n    *,\n    stdin: BinaryIO,\n    retries: int,\n    timeout: int,\n) -> \"subprocess.CompletedProcess[bytes]\":\n    remaining_retries = retries\n    while True:\n        try:\n            return _run_command(args, stdin=stdin, timeout=timeout)\n        except subprocess.TimeoutExpired as err:\n            if remaining_retries == 0:\n                raise err\n            remaining_retries -= 1\n            logging.warning(\n                \"(%s/%s) Retrying because command failed with: %r\",\n                retries - remaining_retries,\n                retries,\n                err,\n            )\n            time.sleep(1)\n\n\ndef check_file(\n    filename: str,\n    retries: int,\n    timeout: int,\n) -> List[LintMessage]:\n    try:\n        with open(filename, \"rb\") as f:\n            original = f.read()\n        with open(filename, \"rb\") as f:\n            proc = run_command(\n                [sys.executable, \"-mblack\", \"--stdin-filename\", filename, \"-\"],\n                stdin=f,\n                retries=retries,\n                timeout=timeout,\n            )\n    except subprocess.TimeoutExpired:\n        return [\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=\"BLACK\",\n                severity=LintSeverity.ERROR,\n                name=\"timeout\",\n                original=None,\n                replacement=None,\n                description=(\n                    \"black timed out while trying to process a file. \"\n                    \"Please report an issue in pytorch/pytorch with the \"\n                    \"label 'module: lint'\"\n                ),\n            )\n        ]\n    except (OSError, subprocess.CalledProcessError) as err:\n        return [\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=\"BLACK\",\n                severity=LintSeverity.ADVICE,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                        stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                    )\n                ),\n            )\n        ]\n\n    replacement = proc.stdout\n    if original == replacement:\n        return []\n\n    return [\n        LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=\"BLACK\",\n            severity=LintSeverity.WARNING,\n            name=\"format\",\n            original=original.decode(\"utf-8\"),\n            replacement=replacement.decode(\"utf-8\"),\n            description=\"Run `lintrunner -a` to apply this patch.\",\n        )\n    ]\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Format files with black.\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--retries\",\n        default=3,\n        type=int,\n        help=\"times to retry timed out black\",\n    )\n    parser.add_argument(\n        \"--timeout\",\n        default=90,\n        type=int,\n        help=\"seconds to wait for black\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=os.cpu_count(),\n        thread_name_prefix=\"Thread\",\n    ) as executor:\n        futures = {\n            executor.submit(check_file, x, args.retries, args.timeout): x\n            for x in args.filenames\n        }\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                for lint_message in future.result():\n                    print(json.dumps(lint_message._asdict()), flush=True)\n            except Exception:\n                logging.critical('Failed at \"%s\".', futures[future])\n                raise\n\n\nif __name__ == \"__main__\":\n    main()\n","replacement":"import argparse\nimport concurrent.futures\nimport json\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom typing import Any, BinaryIO, List, NamedTuple, Optional\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\ndef _run_command(\n    args: List[str],\n    *,\n    stdin: BinaryIO,\n    timeout: int,\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdin=stdin,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            shell=IS_WINDOWS,  # So batch scripts are found.\n            timeout=timeout,\n            check=True,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef run_command(\n    args: List[str],\n    *,\n    stdin: BinaryIO,\n    retries: int,\n    timeout: int,\n) -> \"subprocess.CompletedProcess[bytes]\":\n    remaining_retries = retries\n    while True:\n        try:\n            return _run_command(args, stdin=stdin, timeout=timeout)\n        except subprocess.TimeoutExpired as err:\n            if remaining_retries == 0:\n                raise err\n            remaining_retries -= 1\n            logging.warning(\n                \"(%s/%s) Retrying because command failed with: %r\",\n                retries - remaining_retries,\n                retries,\n                err,\n            )\n            time.sleep(1)\n\n\ndef check_file(\n    filename: str,\n    retries: int,\n    timeout: int,\n) -> List[LintMessage]:\n    try:\n        with open(filename, \"rb\") as f:\n            original = f.read()\n        with open(filename, \"rb\") as f:\n            proc = run_command(\n                [sys.executable, \"-mblack\", \"--stdin-filename\", filename, \"-\"],\n                stdin=f,\n                retries=retries,\n                timeout=timeout,\n            )\n    except subprocess.TimeoutExpired:\n        return [\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=\"BLACK\",\n                severity=LintSeverity.ERROR,\n                name=\"timeout\",\n                original=None,\n                replacement=None,\n                description=(\n                    \"black timed out while trying to process a file. \"\n                    \"Please report an issue in pytorch/pytorch with the \"\n                    \"label 'module: lint'\"\n                ),\n            )\n        ]\n    except (OSError, subprocess.CalledProcessError) as err:\n        return [\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=\"BLACK\",\n                severity=LintSeverity.ADVICE,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                        stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                    )\n                ),\n            )\n        ]\n\n    replacement = proc.stdout\n    if original == replacement:\n        return []\n\n    return [\n        LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=\"BLACK\",\n            severity=LintSeverity.WARNING,\n            name=\"format\",\n            original=original.decode(\"utf-8\"),\n            replacement=replacement.decode(\"utf-8\"),\n            description=\"Run `lintrunner -a` to apply this patch.\",\n        )\n    ]\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Format files with black.\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--retries\",\n        default=3,\n        type=int,\n        help=\"times to retry timed out black\",\n    )\n    parser.add_argument(\n        \"--timeout\",\n        default=90,\n        type=int,\n        help=\"seconds to wait for black\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=os.cpu_count(),\n        thread_name_prefix=\"Thread\",\n    ) as executor:\n        futures = {\n            executor.submit(check_file, x, args.retries, args.timeout): x\n            for x in args.filenames\n        }\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                for lint_message in future.result():\n                    print(json.dumps(lint_message._asdict()), flush=True)\n            except Exception:\n                logging.critical('Failed at \"%s\".', futures[future])\n                raise\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"path":"/adapters/pytorch/mypy_linter.py","line":108,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (80 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/mypy_linter.py","line":119,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (82 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/mypy_linter.py","line":172,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (80 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/mypy_linter.py","line":173,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (88 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/mypy_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"import argparse\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any, Dict, List, NamedTuple, Optional, Pattern\n\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\n# tools/linter/flake8_linter.py:15:13: error: Incompatibl...int\")  [assignment]\nRESULTS_RE: Pattern[str] = re.compile(\n    r\"\"\"(?mx)\n    ^\n    (?P<file>.*?):\n    (?P<line>\\d+):\n    (?:(?P<column>-?\\d+):)?\n    \\s(?P<severity>\\S+?):?\n    \\s(?P<message>.*)\n    \\s(?P<code>\\[.*\\])\n    $\n    \"\"\"\n)\n\n\ndef run_command(\n    args: List[str],\n    *,\n    extra_env: Optional[Dict[str, str]],\n    retries: int,\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\n# Severity is either \"error\" or \"note\":\n# https://github.com/python/mypy/blob/8b47a032e1317fb8e3f9a818005a6b63e9bf0311/mypy/errors.py#L46-L47\nseverities = {\n    \"error\": LintSeverity.ERROR,\n    \"note\": LintSeverity.ADVICE,\n}\n\n\ndef check_files(\n    filenames: List[str],\n    config: str,\n    retries: int,\n) -> List[LintMessage]:\n    try:\n        proc = run_command(\n            [sys.executable, \"-mmypy\", f\"--config={config}\"] + filenames,\n            extra_env={},\n            retries=retries,\n        )\n    except OSError as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=\"MYPY\",\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(f\"Failed due to {err.__class__.__name__}:\\n{err}\"),\n            )\n        ]\n    stdout = str(proc.stdout, \"utf-8\").strip()\n    return [\n        LintMessage(\n            path=match[\"file\"],\n            name=match[\"code\"],\n            description=match[\"message\"],\n            line=int(match[\"line\"]),\n            char=int(match[\"column\"])\n            if match[\"column\"] is not None and not match[\"column\"].startswith(\"-\")\n            else None,\n            code=\"MYPY\",\n            severity=severities.get(match[\"severity\"], LintSeverity.ERROR),\n            original=None,\n            replacement=None,\n        )\n        for match in RESULTS_RE.finditer(stdout)\n    ]\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"mypy wrapper linter.\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--retries\",\n        default=3,\n        type=int,\n        help=\"times to retry timed out mypy\",\n    )\n    parser.add_argument(\n        \"--config\",\n        required=True,\n        help=\"path to an mypy .ini config file\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    # Use a dictionary here to preserve order. mypy cares about order,\n    # tragically, e.g. https://github.com/python/mypy/issues/2015\n    filenames: Dict[str, bool] = {}\n\n    # If a stub file exists, have mypy check it instead of the original file, in\n    # accordance with PEP-484 (see https://www.python.org/dev/peps/pep-0484/#stub-files)\n    for filename in args.filenames:\n        if filename.endswith(\".pyi\"):\n            filenames[filename] = True\n            continue\n\n        stub_filename = filename.replace(\".py\", \".pyi\")\n        if Path(stub_filename).exists():\n            filenames[stub_filename] = True\n        else:\n            filenames[filename] = True\n\n    lint_messages = check_files(list(filenames), args.config, args.retries)\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n\n\nif __name__ == \"__main__\":\n    main()\n","replacement":"import argparse\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any, Dict, List, NamedTuple, Optional, Pattern\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\n# tools/linter/flake8_linter.py:15:13: error: Incompatibl...int\")  [assignment]\nRESULTS_RE: Pattern[str] = re.compile(\n    r\"\"\"(?mx)\n    ^\n    (?P<file>.*?):\n    (?P<line>\\d+):\n    (?:(?P<column>-?\\d+):)?\n    \\s(?P<severity>\\S+?):?\n    \\s(?P<message>.*)\n    \\s(?P<code>\\[.*\\])\n    $\n    \"\"\"\n)\n\n\ndef run_command(\n    args: List[str],\n    *,\n    extra_env: Optional[Dict[str, str]],\n    retries: int,\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\n# Severity is either \"error\" or \"note\":\n# https://github.com/python/mypy/blob/8b47a032e1317fb8e3f9a818005a6b63e9bf0311/mypy/errors.py#L46-L47\nseverities = {\n    \"error\": LintSeverity.ERROR,\n    \"note\": LintSeverity.ADVICE,\n}\n\n\ndef check_files(\n    filenames: List[str],\n    config: str,\n    retries: int,\n) -> List[LintMessage]:\n    try:\n        proc = run_command(\n            [sys.executable, \"-mmypy\", f\"--config={config}\"] + filenames,\n            extra_env={},\n            retries=retries,\n        )\n    except OSError as err:\n        return [\n            LintMessage(\n                path=None,\n                line=None,\n                char=None,\n                code=\"MYPY\",\n                severity=LintSeverity.ERROR,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(f\"Failed due to {err.__class__.__name__}:\\n{err}\"),\n            )\n        ]\n    stdout = str(proc.stdout, \"utf-8\").strip()\n    return [\n        LintMessage(\n            path=match[\"file\"],\n            name=match[\"code\"],\n            description=match[\"message\"],\n            line=int(match[\"line\"]),\n            char=int(match[\"column\"])\n            if match[\"column\"] is not None and not match[\"column\"].startswith(\"-\")\n            else None,\n            code=\"MYPY\",\n            severity=severities.get(match[\"severity\"], LintSeverity.ERROR),\n            original=None,\n            replacement=None,\n        )\n        for match in RESULTS_RE.finditer(stdout)\n    ]\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"mypy wrapper linter.\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--retries\",\n        default=3,\n        type=int,\n        help=\"times to retry timed out mypy\",\n    )\n    parser.add_argument(\n        \"--config\",\n        required=True,\n        help=\"path to an mypy .ini config file\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    # Use a dictionary here to preserve order. mypy cares about order,\n    # tragically, e.g. https://github.com/python/mypy/issues/2015\n    filenames: Dict[str, bool] = {}\n\n    # If a stub file exists, have mypy check it instead of the original file, in\n    # accordance with PEP-484 (see https://www.python.org/dev/peps/pep-0484/#stub-files)\n    for filename in args.filenames:\n        if filename.endswith(\".pyi\"):\n            filenames[filename] = True\n            continue\n\n        stub_filename = filename.replace(\".py\", \".pyi\")\n        if Path(stub_filename).exists():\n            filenames[stub_filename] = True\n        else:\n            filenames[filename] = True\n\n    lint_messages = check_files(list(filenames), args.config, args.retries)\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"path":"/adapters/pytorch/newlines_linter.py","line":57,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (103 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/newlines_linter.py","line":73,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (93 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/newlines_linter.py","line":85,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (103 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/newlines_linter.py","line":90,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (82 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/newlines_linter.py","line":111,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (93 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/newlines_linter.py","line":122,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (98 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/newlines_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"\"\"\"\nNEWLINE: Checks files to make sure there are no trailing newlines.\n\"\"\"\nimport argparse\nimport json\nimport logging\nimport sys\n\nfrom enum import Enum\nfrom typing import List, NamedTuple, Optional\n\nNEWLINE = 10  # ASCII \"\\n\"\nCARRIAGE_RETURN = 13  # ASCII \"\\r\"\nLINTER_CODE = \"NEWLINE\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef check_file(filename: str) -> Optional[LintMessage]:\n    logging.debug(\"Checking file %s\", filename)\n\n    with open(filename, \"rb\") as f:\n        lines = f.readlines()\n\n    if len(lines) == 0:\n        # File is empty, just leave it alone.\n        return None\n\n    if len(lines) == 1 and len(lines[0]) == 1:\n        # file is wrong whether or not the only byte is a newline\n        return LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"testestTrailing newline\",\n            original=None,\n            replacement=None,\n            description=\"Trailing newline found. Run `lintrunner --take NEWLINE -a` to apply changes.\",\n        )\n\n    if len(lines[-1]) == 1 and lines[-1][0] == NEWLINE:\n        try:\n            original = b\"\".join(lines).decode(\"utf-8\")\n        except Exception as err:\n            return LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"Decoding failure\",\n                original=None,\n                replacement=None,\n                description=f\"utf-8 decoding failed due to {err.__class__.__name__}:\\n{err}\",\n            )\n\n        return LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"Trailing newline\",\n            original=original,\n            replacement=original.rstrip(\"\\n\") + \"\\n\",\n            description=\"Trailing newline found. Run `lintrunner --take NEWLINE -a` to apply changes.\",\n        )\n    has_changes = False\n    original_lines: Optional[List[bytes]] = None\n    for idx, line in enumerate(lines):\n        if len(line) >= 2 and line[-1] == NEWLINE and line[-2] == CARRIAGE_RETURN:\n            if not has_changes:\n                original_lines = list(lines)\n                has_changes = True\n            lines[idx] = line[:-2] + b\"\\n\"\n\n    if has_changes:\n        try:\n            assert original_lines is not None\n            original = b\"\".join(original_lines).decode(\"utf-8\")\n            replacement = b\"\".join(lines).decode(\"utf-8\")\n        except Exception as err:\n            return LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"Decoding failure\",\n                original=None,\n                replacement=None,\n                description=f\"utf-8 decoding failed due to {err.__class__.__name__}:\\n{err}\",\n            )\n        return LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"DOS newline\",\n            original=original,\n            replacement=replacement,\n            description=\"DOS newline found. Run `lintrunner --take NEWLINE -a` to apply changes.\",\n        )\n\n    return None\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"native functions linter\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"location of native_functions.yaml\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    lint_messages = []\n    for filename in args.filenames:\n        lint_message = check_file(filename)\n        if lint_message is not None:\n            lint_messages.append(lint_message)\n\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n","replacement":"\"\"\"\nNEWLINE: Checks files to make sure there are no trailing newlines.\n\"\"\"\nimport argparse\nimport json\nimport logging\nimport sys\nfrom enum import Enum\nfrom typing import List, NamedTuple, Optional\n\nNEWLINE = 10  # ASCII \"\\n\"\nCARRIAGE_RETURN = 13  # ASCII \"\\r\"\nLINTER_CODE = \"NEWLINE\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef check_file(filename: str) -> Optional[LintMessage]:\n    logging.debug(\"Checking file %s\", filename)\n\n    with open(filename, \"rb\") as f:\n        lines = f.readlines()\n\n    if len(lines) == 0:\n        # File is empty, just leave it alone.\n        return None\n\n    if len(lines) == 1 and len(lines[0]) == 1:\n        # file is wrong whether or not the only byte is a newline\n        return LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"testestTrailing newline\",\n            original=None,\n            replacement=None,\n            description=\"Trailing newline found. Run `lintrunner --take NEWLINE -a` to apply changes.\",\n        )\n\n    if len(lines[-1]) == 1 and lines[-1][0] == NEWLINE:\n        try:\n            original = b\"\".join(lines).decode(\"utf-8\")\n        except Exception as err:\n            return LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"Decoding failure\",\n                original=None,\n                replacement=None,\n                description=f\"utf-8 decoding failed due to {err.__class__.__name__}:\\n{err}\",\n            )\n\n        return LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"Trailing newline\",\n            original=original,\n            replacement=original.rstrip(\"\\n\") + \"\\n\",\n            description=\"Trailing newline found. Run `lintrunner --take NEWLINE -a` to apply changes.\",\n        )\n    has_changes = False\n    original_lines: Optional[List[bytes]] = None\n    for idx, line in enumerate(lines):\n        if len(line) >= 2 and line[-1] == NEWLINE and line[-2] == CARRIAGE_RETURN:\n            if not has_changes:\n                original_lines = list(lines)\n                has_changes = True\n            lines[idx] = line[:-2] + b\"\\n\"\n\n    if has_changes:\n        try:\n            assert original_lines is not None\n            original = b\"\".join(original_lines).decode(\"utf-8\")\n            replacement = b\"\".join(lines).decode(\"utf-8\")\n        except Exception as err:\n            return LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"Decoding failure\",\n                original=None,\n                replacement=None,\n                description=f\"utf-8 decoding failed due to {err.__class__.__name__}:\\n{err}\",\n            )\n        return LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"DOS newline\",\n            original=original,\n            replacement=replacement,\n            description=\"DOS newline found. Run `lintrunner --take NEWLINE -a` to apply changes.\",\n        )\n\n    return None\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"native functions linter\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"location of native_functions.yaml\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    lint_messages = []\n    for filename in args.filenames:\n        lint_message = check_file(filename)\n        if lint_message is not None:\n            lint_messages.append(lint_message)\n\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n"}
{"path":"/adapters/pytorch/testowners_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"#!/usr/bin/env python3\n# flake8: noqa\n\"\"\"\nTest ownership was introduced in https://github.com/pytorch/pytorch/issues/66232.\n\nThis lint verifies that every Python test file (file that matches test_*.py or *_test.py in the test folder)\nhas valid ownership information in a comment header. Valid means:\n  - The format of the header follows the pattern \"# Owner(s): [\"list\", \"of owner\", \"labels\"]\n  - Each owner label actually exists in PyTorch\n  - Each owner label starts with \"module: \" or \"oncall: \" or is in ACCEPTABLE_OWNER_LABELS\n\"\"\"\nimport argparse\nimport json\nfrom enum import Enum\nfrom typing import Any, List, NamedTuple, Optional\nfrom urllib.request import urlopen\n\n\nLINTER_CODE = \"TESTOWNERS\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\n# Team/owner labels usually start with \"module: \" or \"oncall: \", but the following are acceptable exceptions\nACCEPTABLE_OWNER_LABELS = [\"NNC\", \"high priority\"]\nOWNERS_PREFIX = \"# Owner(s): \"\n\n\ndef get_pytorch_labels() -> Any:\n    labels = (\n        urlopen(\"https://ossci-metrics.s3.amazonaws.com/pytorch_labels.json\")\n        .read()\n        .decode(\"utf-8\")\n    )\n    return json.loads(labels)\n\n\nPYTORCH_LABELS = get_pytorch_labels()\n# Team/owner labels usually start with \"module: \" or \"oncall: \", but the following are acceptable exceptions\nACCEPTABLE_OWNER_LABELS = [\"NNC\", \"high priority\"]\nGLOB_EXCEPTIONS = [\"**/test/run_test.py\"]\n\n\ndef check_labels(\n    labels: List[str], filename: str, line_number: int\n) -> List[LintMessage]:\n    lint_messages = []\n    for label in labels:\n        if label not in PYTORCH_LABELS:\n            lint_messages.append(\n                LintMessage(\n                    path=filename,\n                    line=line_number,\n                    char=None,\n                    code=LINTER_CODE,\n                    severity=LintSeverity.ERROR,\n                    name=\"[invalid-label]\",\n                    original=None,\n                    replacement=None,\n                    description=(\n                        f\"{label} is not a PyTorch label \"\n                        \"(please choose from https://github.com/pytorch/pytorch/labels)\"\n                    ),\n                )\n            )\n\n        if (\n            label.startswith(\"module:\")\n            or label.startswith(\"oncall:\")\n            or label in ACCEPTABLE_OWNER_LABELS\n        ):\n            continue\n\n        lint_messages.append(\n            LintMessage(\n                path=filename,\n                line=line_number,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"[invalid-owner]\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"{label} is not an acceptable owner \"\n                    \"(please update to another label or edit ACCEPTABLE_OWNERS_LABELS \"\n                    \"in tools/linters/adapters/testowners_linter.py\"\n                ),\n            )\n        )\n\n    return lint_messages\n\n\ndef check_file(filename: str) -> List[LintMessage]:\n    lint_messages = []\n    has_ownership_info = False\n\n    with open(filename) as f:\n        for idx, line in enumerate(f):\n            if not line.startswith(OWNERS_PREFIX):\n                continue\n\n            has_ownership_info = True\n            labels = json.loads(line[len(OWNERS_PREFIX) :])\n            lint_messages.extend(check_labels(labels, filename, idx + 1))\n\n    if has_ownership_info is False:\n        lint_messages.append(\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"[no-owner-info]\",\n                original=None,\n                replacement=None,\n                description=\"Missing a comment header with ownership information.\",\n            )\n        )\n\n    return lint_messages\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"test ownership linter\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    args = parser.parse_args()\n    lint_messages = []\n\n    for filename in args.filenames:\n        lint_messages.extend(check_file(filename))\n\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n\n\nif __name__ == \"__main__\":\n    main()\n","replacement":"#!/usr/bin/env python3\n# flake8: noqa\n\"\"\"\nTest ownership was introduced in https://github.com/pytorch/pytorch/issues/66232.\n\nThis lint verifies that every Python test file (file that matches test_*.py or *_test.py in the test folder)\nhas valid ownership information in a comment header. Valid means:\n  - The format of the header follows the pattern \"# Owner(s): [\"list\", \"of owner\", \"labels\"]\n  - Each owner label actually exists in PyTorch\n  - Each owner label starts with \"module: \" or \"oncall: \" or is in ACCEPTABLE_OWNER_LABELS\n\"\"\"\nimport argparse\nimport json\nfrom enum import Enum\nfrom typing import Any, List, NamedTuple, Optional\nfrom urllib.request import urlopen\n\nLINTER_CODE = \"TESTOWNERS\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\n# Team/owner labels usually start with \"module: \" or \"oncall: \", but the following are acceptable exceptions\nACCEPTABLE_OWNER_LABELS = [\"NNC\", \"high priority\"]\nOWNERS_PREFIX = \"# Owner(s): \"\n\n\ndef get_pytorch_labels() -> Any:\n    labels = (\n        urlopen(\"https://ossci-metrics.s3.amazonaws.com/pytorch_labels.json\")\n        .read()\n        .decode(\"utf-8\")\n    )\n    return json.loads(labels)\n\n\nPYTORCH_LABELS = get_pytorch_labels()\n# Team/owner labels usually start with \"module: \" or \"oncall: \", but the following are acceptable exceptions\nACCEPTABLE_OWNER_LABELS = [\"NNC\", \"high priority\"]\nGLOB_EXCEPTIONS = [\"**/test/run_test.py\"]\n\n\ndef check_labels(\n    labels: List[str], filename: str, line_number: int\n) -> List[LintMessage]:\n    lint_messages = []\n    for label in labels:\n        if label not in PYTORCH_LABELS:\n            lint_messages.append(\n                LintMessage(\n                    path=filename,\n                    line=line_number,\n                    char=None,\n                    code=LINTER_CODE,\n                    severity=LintSeverity.ERROR,\n                    name=\"[invalid-label]\",\n                    original=None,\n                    replacement=None,\n                    description=(\n                        f\"{label} is not a PyTorch label \"\n                        \"(please choose from https://github.com/pytorch/pytorch/labels)\"\n                    ),\n                )\n            )\n\n        if (\n            label.startswith(\"module:\")\n            or label.startswith(\"oncall:\")\n            or label in ACCEPTABLE_OWNER_LABELS\n        ):\n            continue\n\n        lint_messages.append(\n            LintMessage(\n                path=filename,\n                line=line_number,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"[invalid-owner]\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"{label} is not an acceptable owner \"\n                    \"(please update to another label or edit ACCEPTABLE_OWNERS_LABELS \"\n                    \"in tools/linters/adapters/testowners_linter.py\"\n                ),\n            )\n        )\n\n    return lint_messages\n\n\ndef check_file(filename: str) -> List[LintMessage]:\n    lint_messages = []\n    has_ownership_info = False\n\n    with open(filename) as f:\n        for idx, line in enumerate(f):\n            if not line.startswith(OWNERS_PREFIX):\n                continue\n\n            has_ownership_info = True\n            labels = json.loads(line[len(OWNERS_PREFIX) :])\n            lint_messages.extend(check_labels(labels, filename, idx + 1))\n\n    if has_ownership_info is False:\n        lint_messages.append(\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=LINTER_CODE,\n                severity=LintSeverity.ERROR,\n                name=\"[no-owner-info]\",\n                original=None,\n                replacement=None,\n                description=\"Missing a comment header with ownership information.\",\n            )\n        )\n\n    return lint_messages\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"test ownership linter\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    args = parser.parse_args()\n    lint_messages = []\n\n    for filename in args.filenames:\n        lint_messages.extend(check_file(filename))\n\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"path":"/adapters/pytorch/exec_linter.py","line":47,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (101 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/exec_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"\"\"\"\nEXEC: Ensure that source files are not executable.\n\"\"\"\nimport argparse\nimport json\nimport logging\nimport os\nimport sys\n\nfrom enum import Enum\nfrom typing import NamedTuple, Optional\n\nLINTER_CODE = \"EXEC\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef check_file(filename: str) -> Optional[LintMessage]:\n    is_executable = os.access(filename, os.X_OK)\n    if is_executable:\n        return LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"executable-permissions\",\n            original=None,\n            replacement=None,\n            description=\"This file has executable permission; please remove it by using `chmod -x`.\",\n        )\n    return None\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"exec linter\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    lint_messages = []\n    for filename in args.filenames:\n        lint_message = check_file(filename)\n        if lint_message is not None:\n            lint_messages.append(lint_message)\n\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n","replacement":"\"\"\"\nEXEC: Ensure that source files are not executable.\n\"\"\"\nimport argparse\nimport json\nimport logging\nimport os\nimport sys\nfrom enum import Enum\nfrom typing import NamedTuple, Optional\n\nLINTER_CODE = \"EXEC\"\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef check_file(filename: str) -> Optional[LintMessage]:\n    is_executable = os.access(filename, os.X_OK)\n    if is_executable:\n        return LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=LINTER_CODE,\n            severity=LintSeverity.ERROR,\n            name=\"executable-permissions\",\n            original=None,\n            replacement=None,\n            description=\"This file has executable permission; please remove it by using `chmod -x`.\",\n        )\n    return None\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"exec linter\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    lint_messages = []\n    for filename in args.filenames:\n        lint_message = check_file(filename)\n        if lint_message is not None:\n            lint_messages.append(lint_message)\n\n    for lint_message in lint_messages:\n        print(json.dumps(lint_message._asdict()), flush=True)\n"}
{"path":"/adapters/pytorch/clangformat_linter.py","line":163,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (118 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/clangformat_linter.py","line":236,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (81 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/clangformat_linter.py","line":null,"char":null,"code":"BLACK-ISORT","severity":"warning","name":"format","description":"Run `lintrunner -a` to apply this patch.","original":"import argparse\nimport concurrent.futures\nimport json\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any, List, NamedTuple, Optional\n\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\ndef _run_command(\n    args: List[str],\n    *,\n    timeout: int,\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            shell=IS_WINDOWS,  # So batch scripts are found.\n            timeout=timeout,\n            check=True,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef run_command(\n    args: List[str],\n    *,\n    retries: int,\n    timeout: int,\n) -> \"subprocess.CompletedProcess[bytes]\":\n    remaining_retries = retries\n    while True:\n        try:\n            return _run_command(args, timeout=timeout)\n        except subprocess.TimeoutExpired as err:\n            if remaining_retries == 0:\n                raise err\n            remaining_retries -= 1\n            logging.warning(\n                \"(%s/%s) Retrying because command failed with: %r\",\n                retries - remaining_retries,\n                retries,\n                err,\n            )\n            time.sleep(1)\n\n\ndef check_file(\n    filename: str,\n    binary: str,\n    retries: int,\n    timeout: int,\n) -> List[LintMessage]:\n    try:\n        with open(filename, \"rb\") as f:\n            original = f.read()\n        proc = run_command(\n            [binary, filename],\n            retries=retries,\n            timeout=timeout,\n        )\n    except subprocess.TimeoutExpired:\n        return [\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=\"CLANGFORMAT\",\n                severity=LintSeverity.ERROR,\n                name=\"timeout\",\n                original=None,\n                replacement=None,\n                description=(\n                    \"clang-format timed out while trying to process a file. \"\n                    \"Please report an issue in pytorch/pytorch with the \"\n                    \"label 'module: lint'\"\n                ),\n            )\n        ]\n    except (OSError, subprocess.CalledProcessError) as err:\n        return [\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=\"CLANGFORMAT\",\n                severity=LintSeverity.ADVICE,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                        stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                    )\n                ),\n            )\n        ]\n\n    replacement = proc.stdout\n    if original == replacement:\n        return []\n\n    return [\n        LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=\"CLANGFORMAT\",\n            severity=LintSeverity.WARNING,\n            name=\"format\",\n            original=original.decode(\"utf-8\"),\n            replacement=replacement.decode(\"utf-8\"),\n            description=\"See https://clang.llvm.org/docs/ClangFormat.html.\\nRun `lintrunner -a` to apply this patch.\",\n        )\n    ]\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Format files with clang-format.\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--binary\",\n        required=True,\n        help=\"clang-format binary path\",\n    )\n    parser.add_argument(\n        \"--retries\",\n        default=3,\n        type=int,\n        help=\"times to retry timed out clang-format\",\n    )\n    parser.add_argument(\n        \"--timeout\",\n        default=90,\n        type=int,\n        help=\"seconds to wait for clang-format\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    binary = os.path.normpath(args.binary) if IS_WINDOWS else args.binary\n    if not Path(binary).exists():\n        lint_message = LintMessage(\n            path=None,\n            line=None,\n            char=None,\n            code=\"CLANGFORMAT\",\n            severity=LintSeverity.ERROR,\n            name=\"init-error\",\n            original=None,\n            replacement=None,\n            description=(\n                f\"Could not find clang-format binary at {binary}, \"\n                \"did you forget to run `lintrunner init`?\"\n            ),\n        )\n        print(json.dumps(lint_message._asdict()), flush=True)\n        sys.exit(0)\n\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=os.cpu_count(),\n        thread_name_prefix=\"Thread\",\n    ) as executor:\n        futures = {\n            executor.submit(check_file, x, binary, args.retries, args.timeout): x\n            for x in args.filenames\n        }\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                for lint_message in future.result():\n                    print(json.dumps(lint_message._asdict()), flush=True)\n            except Exception:\n                logging.critical('Failed at \"%s\".', futures[future])\n                raise\n\n\nif __name__ == \"__main__\":\n    main()\n","replacement":"import argparse\nimport concurrent.futures\nimport json\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any, List, NamedTuple, Optional\n\nIS_WINDOWS: bool = os.name == \"nt\"\n\n\ndef eprint(*args: Any, **kwargs: Any) -> None:\n    print(*args, file=sys.stderr, flush=True, **kwargs)\n\n\nclass LintSeverity(str, Enum):\n    ERROR = \"error\"\n    WARNING = \"warning\"\n    ADVICE = \"advice\"\n    DISABLED = \"disabled\"\n\n\nclass LintMessage(NamedTuple):\n    path: Optional[str]\n    line: Optional[int]\n    char: Optional[int]\n    code: str\n    severity: LintSeverity\n    name: str\n    original: Optional[str]\n    replacement: Optional[str]\n    description: Optional[str]\n\n\ndef as_posix(name: str) -> str:\n    return name.replace(\"\\\\\", \"/\") if IS_WINDOWS else name\n\n\ndef _run_command(\n    args: List[str],\n    *,\n    timeout: int,\n) -> \"subprocess.CompletedProcess[bytes]\":\n    logging.debug(\"$ %s\", \" \".join(args))\n    start_time = time.monotonic()\n    try:\n        return subprocess.run(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            shell=IS_WINDOWS,  # So batch scripts are found.\n            timeout=timeout,\n            check=True,\n        )\n    finally:\n        end_time = time.monotonic()\n        logging.debug(\"took %dms\", (end_time - start_time) * 1000)\n\n\ndef run_command(\n    args: List[str],\n    *,\n    retries: int,\n    timeout: int,\n) -> \"subprocess.CompletedProcess[bytes]\":\n    remaining_retries = retries\n    while True:\n        try:\n            return _run_command(args, timeout=timeout)\n        except subprocess.TimeoutExpired as err:\n            if remaining_retries == 0:\n                raise err\n            remaining_retries -= 1\n            logging.warning(\n                \"(%s/%s) Retrying because command failed with: %r\",\n                retries - remaining_retries,\n                retries,\n                err,\n            )\n            time.sleep(1)\n\n\ndef check_file(\n    filename: str,\n    binary: str,\n    retries: int,\n    timeout: int,\n) -> List[LintMessage]:\n    try:\n        with open(filename, \"rb\") as f:\n            original = f.read()\n        proc = run_command(\n            [binary, filename],\n            retries=retries,\n            timeout=timeout,\n        )\n    except subprocess.TimeoutExpired:\n        return [\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=\"CLANGFORMAT\",\n                severity=LintSeverity.ERROR,\n                name=\"timeout\",\n                original=None,\n                replacement=None,\n                description=(\n                    \"clang-format timed out while trying to process a file. \"\n                    \"Please report an issue in pytorch/pytorch with the \"\n                    \"label 'module: lint'\"\n                ),\n            )\n        ]\n    except (OSError, subprocess.CalledProcessError) as err:\n        return [\n            LintMessage(\n                path=filename,\n                line=None,\n                char=None,\n                code=\"CLANGFORMAT\",\n                severity=LintSeverity.ADVICE,\n                name=\"command-failed\",\n                original=None,\n                replacement=None,\n                description=(\n                    f\"Failed due to {err.__class__.__name__}:\\n{err}\"\n                    if not isinstance(err, subprocess.CalledProcessError)\n                    else (\n                        \"COMMAND (exit code {returncode})\\n\"\n                        \"{command}\\n\\n\"\n                        \"STDERR\\n{stderr}\\n\\n\"\n                        \"STDOUT\\n{stdout}\"\n                    ).format(\n                        returncode=err.returncode,\n                        command=\" \".join(as_posix(x) for x in err.cmd),\n                        stderr=err.stderr.decode(\"utf-8\").strip() or \"(empty)\",\n                        stdout=err.stdout.decode(\"utf-8\").strip() or \"(empty)\",\n                    )\n                ),\n            )\n        ]\n\n    replacement = proc.stdout\n    if original == replacement:\n        return []\n\n    return [\n        LintMessage(\n            path=filename,\n            line=None,\n            char=None,\n            code=\"CLANGFORMAT\",\n            severity=LintSeverity.WARNING,\n            name=\"format\",\n            original=original.decode(\"utf-8\"),\n            replacement=replacement.decode(\"utf-8\"),\n            description=\"See https://clang.llvm.org/docs/ClangFormat.html.\\nRun `lintrunner -a` to apply this patch.\",\n        )\n    ]\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Format files with clang-format.\",\n        fromfile_prefix_chars=\"@\",\n    )\n    parser.add_argument(\n        \"--binary\",\n        required=True,\n        help=\"clang-format binary path\",\n    )\n    parser.add_argument(\n        \"--retries\",\n        default=3,\n        type=int,\n        help=\"times to retry timed out clang-format\",\n    )\n    parser.add_argument(\n        \"--timeout\",\n        default=90,\n        type=int,\n        help=\"seconds to wait for clang-format\",\n    )\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"verbose logging\",\n    )\n    parser.add_argument(\n        \"filenames\",\n        nargs=\"+\",\n        help=\"paths to lint\",\n    )\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"<%(threadName)s:%(levelname)s> %(message)s\",\n        level=logging.NOTSET\n        if args.verbose\n        else logging.DEBUG\n        if len(args.filenames) < 1000\n        else logging.INFO,\n        stream=sys.stderr,\n    )\n\n    binary = os.path.normpath(args.binary) if IS_WINDOWS else args.binary\n    if not Path(binary).exists():\n        lint_message = LintMessage(\n            path=None,\n            line=None,\n            char=None,\n            code=\"CLANGFORMAT\",\n            severity=LintSeverity.ERROR,\n            name=\"init-error\",\n            original=None,\n            replacement=None,\n            description=(\n                f\"Could not find clang-format binary at {binary}, \"\n                \"did you forget to run `lintrunner init`?\"\n            ),\n        )\n        print(json.dumps(lint_message._asdict()), flush=True)\n        sys.exit(0)\n\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=os.cpu_count(),\n        thread_name_prefix=\"Thread\",\n    ) as executor:\n        futures = {\n            executor.submit(check_file, x, binary, args.retries, args.timeout): x\n            for x in args.filenames\n        }\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                for lint_message in future.result():\n                    print(json.dumps(lint_message._asdict()), flush=True)\n            except Exception:\n                logging.critical('Failed at \"%s\".', futures[future])\n                raise\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":3,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (84 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":4,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (81 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":5,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (89 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":6,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (91 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":9,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (85 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":10,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (89 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":11,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (86 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":12,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (89 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":13,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (87 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":65,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (81 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":102,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (116 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
{"path":"/adapters/pytorch/nativefunctions_linter.py","line":103,"char":80,"code":"FLAKE8","severity":"advice","name":"E501","description":"line too long (107 > 79 characters)\nSee https://www.flake8rules.com/rules/E501.html"}
